---
title: "Basic Model formulation"
author: "Florian D. Schneider"
date: "Tuesday, November 18, 2014"
output:
  pdf_document:
    fig_height: 4
    fig_width: 6
  html_document:
    keep_md: yes
fontsize: 12pt
geometry: margin=1.4in
csl: ../manuscript/amnat.csl
bibliography: ../manuscript/cas02.bib
---

This document is supposed to develop a model representation of the global mean field as well as pair-approximations of local feed back mechanisms. 

The default form of the differential equation describing vegetation cover is 

$$ \frac{dV}{dt} = G(V) - C(V)L $$

with growth function $G$ and a function $C$ which represents consumption by a herbivore multiplied by the density of herbivores, the livestock rate, $L$. Formally, intrinsic mortality could be included in both terms. In the formulations of @noy-meir75 and @vandekoppel97 it is assumed to be covered by the logistic growth function.

It might become important in the pair-approximation model, where intrinsic plant mortality is included as a proportional loss of mature plants.

```{r, echo=FALSE}
# Default plotting function

defplot <- function(...) plot(..., 
            type = "l", 
            bty = "l", cex = 0.7, las = 1,
            xlim = c(0,1), ylim = c(0,0.4), 
            xaxs = "i", yaxs = "i", 
            xaxp = c(0,1,2), yaxp = c(0,1,2), 
            xlab = "vegetation cover") 

rho <- seq(0,1,length = 100)

```

## non-spatial models

### logistic growth

If assuming phenomenological logistic growth, the gain in vegetation as a function of present vegetation cover is 

$$ G(V) = rV(1-\frac{V}{K}) \,,$$

with the growth rate, $r$, and the carrying capacity, $K$, decelerating the exponential growth as vegetation cover increases and reducing it to zero if $V \geq K$. Thus, it is a decelerating effect (a negative feed-back) at high vegetation cover. 

```{r, echo=FALSE}

G <- function(P, r = 1, K = 1) r*P*(1-P/K)

defplot(rho, G(rho), ylab = "growth")

```

**This model is going to be the starting point for the model development**

#### mechanistic growth assumptions

In the first place the logistic growth model is phenomenological and does not provide a particular ecological explanation, why growth is decelerating to zero with increasing cover. It assumes just some form of global competition leading to a balance of gains and losses at the carrying capacity of the ecosystem. 

Mechanistic explanations can be the limitations by a globally diffuse resource, like water, or the occupation of space and the subsequent limitation of photosynthetic active surface. 

A multitude of such global feedback processes can define the precise shape of the growth function leading to asymetrical or truncated shapes, which could importantly affect the bistability properties of the system [@noy-meir75]. He defines

> The general shape of the growth function relating net growth to plant biomass, $G(V)$, is convex with a single maximum (Fig. 1). The increase in the low-biomass range expresses the increase in photosynthetic capacity with increasing leaf area. The levelling off to a plateau and the decrease in the higher range expresses self-interference effects (shading, competition); at the point $V = V_\mathrm{max}$ 'maintenance' losses equal photosynthesis and $G = 0$. Vmax is the maximum (stable) biomass in ungrazed vegetation. [...] Of the explicit forms the best known is the logistic [...] but other functions are possible.

We consider these multiple competitive effects being of minor relevance for now and start with a single limitation by the factor space. As the landscape becomes more and more filled with vegetation, the empty space become scarce. Thus, growth declines until each potentially habitable spot is occupied. We implement a generally valid carrying capacity, $K$. 

We assume that growth rate is linearly related to environmental quality, $b$, which is inverse to aridity. Since drylands are water limited in the first place, this factor defines the reproduction rate (i.e. number of seeds produced per plant, number of seedlings surviving the harshness of the dry soils). We assume that

$$ r = r_0 b $$ 

to have a gradient of environmental harshness, $b$, reaching from 0 to 1. 
The model thus starts out with the assumption of decelerating growth due to competition for space. 

#### accelerating growth   

In arid ecosystems, growth rates would be lowest at very low cover and accelerate as cover increases, because retention of water and organic matter in the site is fundamentally reduced and water runoff is high. This postive feed-back (low cover reduces growth, leading to even lower cover) was discussed by @vandekoppel97 and @rietkerk97 to explain bistability in arid ecosystems.

Starting out from the logistic growth term, we now additionally assume that $r$ is accelerated with cover,

$$ r = r_0 b V^a $$

$$ G(V) = r_0 b V^{a+1} (1-\frac{V}{K}) \,,$$


```{r, echo=FALSE}


r <- function(P, r_0 =  1, a = 1) r_0 *P^a

#defplot(rho, r(rho), ylab = "growth")

G_sig <- function(P, r_0 = 1, a = 1,  K = 0.9) r(P, r_0, a)*P*(1-P/K)

defplot(rho, G_sig(rho), ylab = "growth")
lines(rho, G_sig(rho, a = 0))
lines(rho, G_sig(rho, a = 1))
lines(rho, G_sig(rho, a = 0.2))
```

### plant mortality

#### linear plant mortality

In the cellular automata model and mean-field approximations of @kefi07, individual plant mortality is a constant rate, which means it is increasing linearly with vegetation cover. Total plant mortality due to grazing therefore would be described as

$$ C(V) = gVL \,, $$

with the grazing mortality, $g$, per grazer individual multiplied by livestock density, $L$. That is to say, per individual, a constant percentage of cover is eaten. That is, ecologically speaking, not realistic. 


```{r, echo=FALSE}
C <- function(V, L = 5, g = 0.01) (g*V*L)

defplot(rho, C(rho), ylab = "plant mortality")

```

#### constant plant mortality

In fact, when assuming a constant density of herbivores, grazing mortality will certainly saturate at some point, due to limitations of the herbivores handling times. A very parsimonious model would assume that grazing always is defined by this limitation of handling times, even at very low densities. 

Mortality due to grazing,

$$ C(V) = gL \,, $$

thus could be defined as constant, $g$, per grazer individual regardless of the vegetation cover.


```{r, echo=FALSE}
C <- function(V, L = 5, g = 0.01) g * L + V*0

defplot(rho, C(rho), ylab = "plant mortality")

```

Note that grazing mortality can exceed 1, meaning that grazers would exploit more biomass than provided at full cover. Thus stability can be only reached if growth is sufficiently higher and the landscape regenerates itself multiple times per year. 

#### type 2 functional response

In natural systems, however, consumption is defined by saturating functional responses, i.e. at low cover, density dependent mortality defined by search efficiency dominates, but at high cover handling times of the consumer will limit its intake rates. Therefore, plant mortality due to grazing should be 

$$ C(V) = \frac{aVL}{1+ahV} \,,$$

with the handling time, $h$ [time per landscape unit], and the search efficiency, $a$ [percent of landscape foraged in per time]. 

```{r, echo=FALSE}
C <- function(V, L = 5, a = 0.6, h = 100) (a*V*L)/(1+a*h*V)

defplot(rho, C(rho), ylab = "plant mortality")

```

Since we are calculating in fractions of landscape, i.e. vegetation cover, and not in cells, the handling time defines the time a grazer individual would need to handle the entire landscape as readily available fodder. The search time is the percentage of the landscape foraged in over the course of one year.  


#### type 3 functional response

As an accelerating assumption on plant mortality we add the formulation of density dependent search efficiencies. 

$$ b = b_0 N^q $$

Which turns the consumption term into 

$$ C(V) = \frac{bV^{1+q}}{1+bhV^{1+q}} $$

Thus, plant mortality is accelerating with increasing cover, protecting plants at low cover, due to inefficient search behaviour, and then saturates at the inverse of handling time, $h$. 


```{r, echo=FALSE}
C <- function(V, L = 5, a = 0.6, h = 100, q = 1) (a*V^(1+q)*L)/(1+a*h*(V^(1+q)) ) 

defplot(rho, C(rho), ylab = "plant mortality")

```

#### consumption null model

We assume the classic type II functional response plus an intrinsic mortality rate, 

$$ C(V) = mV + \frac{aVL}{1+ahV} \,,$$


```{r, echo=FALSE}

C <- function(V, m_0 = 0.05, L = 5, a = 0.6, h = 100, q = 0) (m_0 * V) +(a*V^(1+q)*L)/(1+a*h*(V^(1+q)) ) 

defplot(rho, C(rho), ylab = "plant mortality")
abline(a = 0, b = 0.05, lty = 2)
```

**This model is going to be the starting point for our model development**


### bistability

Plotting the growth rate against the different mortality rates shows how the definition of grazing mortality alters our prediction of the steady states of the system. 

Compared to the more realistic non-linear functions, the constant grazing mortality assumption seems to predict both the attractor of the vegetated state and the tipping point much better than the density dependent mortality used in Kéfi et al 2007 TPB. In fact, the linear density dependent mortality does not predict bistability at all, given a simple logistic growth function. 


```{r, echo=FALSE}

defplot(rho, G(rho), ylab = "growth", col = "green3")
lines(rho, C(rho, L = 10, a = 0.01, h = 0.00001))
lines(rho, C(rho, L = 25, a = 0.01, h = 0.00001))
lines(rho, C(rho, L = 50, a = 0.01, h = 0.00001))
abline( h = 0.1 )
abline( h = 0.25 )
```


When assuming a type II functional response, the system gains true bistability. 

```{r, echo=FALSE}

defplot(rho, G(rho), ylab = "growth", col = "green3")
lines(rho, C(rho, L = 5))
lines(rho, C(rho, L = 10))
lines(rho, C(rho, L = 25))

```


The type 3 functional response finally predicts the existance of a stable degraded state that is not a desert, i.e. not entirely unvegetated. 

```{r, echo=FALSE}

defplot(rho, G(rho), ylab = "growth", col = "green3")
lines(rho, C(rho, L = 5, q = 1))
lines(rho, C(rho, L = 10, q = 1))
lines(rho, C(rho, L = 25, q = 1))

```

### population dynamics

The differential equation describing population cover above with $V$ and $C$ substituted would then become  

$$ \frac{\mathrm{d}V}{\mathrm{d}t} = r b V (1-\frac{V}{K}) - m V - \frac{aVL}{1+ahV} $$

Given a parameter set  
```{r, echo=FALSE}

parms <- list(
    m = 0.05,
    r = 1,
    b = 0.9, 
    K = 0.9, 
    a = 0.6,
    h = 100,
    L = 5
  )

 as.data.frame(parms)
```
we receive a projection of the intersection of growth and mortality.

```{r, echo=FALSE}
plot(rho,  with(parms,  m * rho + (a * rho * L)/(1 + a * h * rho)), ylab = "growth", type = "l", ylim = c(0,0.5))
lines(rho, with(parms, r* b* rho * (1 - rho/K) ), col = "green3" )

```

And solving the ODE, starting with values larger than the unstable equilibrium point on the left,  returns a timeseries 

```{r, echo=FALSE}
d_rho <- function(rho, parms, z = 4) { 
  with(parms, r* b* rho * (1 - rho/K) - m * rho - (a * rho * L)/(1 + a * h * rho) )  
}


odesys <- function (t, rho, parms = model_parms) {
  list( d_rho(rho, parms)  )
}

library(deSolve)
# running the ode-solver
runmodel <- ode(y = 0.90, func = odesys, times = 1.1^(1:53), parms = parms)

# transfer into ouput and calculate missing rho values
ODEnullmodel <- as.data.frame(runmodel)


plot(ODEnullmodel, type = "l", ylim = c(0,1))
axis(4, at = round(tail(ODEnullmodel,1)[["1"]],2),cex.axis = 0.8, las = 1 )

```

#### global model

The ODE that includes the additional global feed backs of water runoff and  reduced search efficience at low cover would read: 

$$ \frac{\mathrm{d}V}{\mathrm{d}t} = r b V^{1 + \alpha} (1-\frac{V}{K}) - m V - \frac{aV^{1+q}L}{1+ahV^{1+q}} $$

We extend the parameter set by 

```{r, echo=FALSE}

parms <- list(
    m = 0.05,
    r = 1,
    b = 0.9, 
    K = 0.9, 
    a = 0.6,
    h = 100,
    L = 16, 
    alpha = 0.1,
    q = 1
  )

 as.data.frame(parms)
```

which gives us the prediction of complex bistability.

```{r, echo=FALSE}
plot(rho,  with(parms,  m * rho + (a * rho^( 1 + q) * L)/(1 + a * h * rho^( 1 + q))), ylab = "growth", type = "l", ylim = c(0,0.5))
  lines(rho, with(parms, r* b* rho^( 1 + alpha) * (1 - rho/K) ), col = "green3" )


d_rho <- function(rho, parms, z = 4) { 
  with(parms, r* b* rho^( 1 + alpha) * (1 - rho/K) - m * rho - (a * rho^( 1 + q) * L)/(1 + a * h * rho^( 1 + q)) )  
  }
  
# running the ode-solver
ODEglobal_high <- ode(y = 0.9, func = odesys, times = 1.1^(1:50), parms = parms)

# transfer into ouput and calculate missing rho values
ODEglobal_high <- as.data.frame(ODEglobal_high)

plot(ODEglobal_high, type = "l", ylim = c(0,1))
axis(4, at = round(tail(ODEglobal_high,1)[["1"]],2),cex.axis = 0.75, las = 1 )


# running the ode-solver
ODEglobal_low <- ode(y = 0.1, func = odesys, times = 1.1^(1:50), parms = parms)

# transfer into ouput and calculate missing rho values
ODEglobal_low <- as.data.frame(ODEglobal_low)
axis(4, at = round(tail(ODEglobal_low,1)[["1"]],2),cex.axis = 0.75, las = 1 )

lines(ODEglobal_low)

```


### Cellular Automata

It is straigthforward to implement the model in a cellular automata model. It is defined on a defined grid of cells where each cell can take the values '1' if it is vegetated and '0' if it is empty. The transition rules between those states depend on global vegetation cover, $\rho_1$. 

While the differential equations are formulated as changes in vegetation cover(growth are positive changes, and deaths are negative changes), the CA uses transition probabilities between the two possible cell states. Thus, two transition probabilities need to be defined: the probability of **growth**, $w_{0,1}$, turning an empty cell into a vegetated, and the probability of **death**, $w_{0,1}$, removing vegetation from the cell.

To translate into the CA context, we need to find rules that apply to a) the vegetated cells, and b) the empty cells. Thus, it would be a) the reduction of term of the population of vegetated cells, divided by cover, to get the individual risk of death

$$ w_{1,0} = m + \frac{aL}{1+ah\rho_1} $$


This would be b) the growth term for the population of empty cells, divided by cover of empty cells, to get the individual chance of growth.

$$ w_{0,1} = \frac{r \rho_1 b (1-\frac{\rho_1}{K})}{1-\rho_1} $$
 

From an individual cell perspective, the probabilities would change along with cover like this

```{r, echo=FALSE}

parms <- list(
    m = 0.05,
    r = 1,
    b = 0.9, 
    K = 0.9, 
    a = 0.6,
    h = 100,
    L = 5, 
    alpha = 0,
    q = 0,
    c = 0,
    f = 0,
    v = 0,
    p = 0
  )

par(mar = c(4,4,2,4))
plot(rho,  with(parms,  r * b * rho * ( 1 - (rho / K)) / (1 - rho) ) , ylab = "individual growth on empty cells", type = "l", ylim = c(0,2.5), las = 1, yaxs = "i")

lines(rho, with(parms, m + ( a * L )/( 1 + a * h * rho ) ), col = "red3" )
axis(4, las = 1)
mtext("individual risk of death of vegetated cells", 4, 3)
```

Running this on a 100 x 100 grid of cells in a timeseries of 150 years yields (dashed line: ODE prediction as reference)

```{r, echo = FALSE, warning = FALSE}

source("../code/simfunctions.r")

set.seed(584232) # setting seed for random number generation

nullmodel <- runCA(0.9, parms, delta = 0.2, t_max = 150, t_min = 100, t_eval = 50, isstable = 0.0001, saveeach = 1)


plot(nullmodel$rho_one ~ nullmodel$time, 
     ylim = c(0,1), ylab = expression( rho["+"]), 
     xlab = "time [yr]", type = "l")
     

lines(ODEnullmodel, lty = 3)
```

And the animated lattice would look like this:
```{r, eval = FALSE, echo = FALSE, warning = FALSE}
animateCA(nullmodel, "ca_nullmodel.gif")

![](ca_nullmodel.gif)

```


#### additional feedbacks

The next step is to include the additional global feedback terms into the model. This is straightforward 

$$ w_{1,0} = m + \frac{aL\rho_1^{q}}{1+ah\rho_1^{1+q}} $$

$$ w_{0,1} = \frac{r \rho_1^{1+\alpha} b (1-\frac{\rho_1}{K})}{1-\rho_1} $$

```{r, echo=FALSE}

parms <- list(
    m = 0.05,
    r = 1,
    b = 0.9, 
    K = 0.9, 
    a = 0.6,
    h = 100,
    L = 16, 
    alpha = 0.1,
    q = 1,
    c = 0,
    f = 0,
    v = 0,
    p = 0
    
  )

set.seed(5535732) # setting seed for random number generation

globalmodel <- runCA(0.9, parms, delta = 0.2, t_max = 150, t_min = 100, t_eval = 50, isstable = 0.0001, saveeach = 1)


plot(globalmodel$rho_one ~ globalmodel$time, 
     ylim = c(0,1), ylab = expression( rho["+"]), 
     xlab = "time [yr]", type = "l")
     

globalmodel <- runCA(0.1, parms, delta = 0.2, t_max = 150, t_min = 100, t_eval = 50, isstable = 0.0001, saveeach = 1)
lines(globalmodel$rho_one ~ globalmodel$time)
lines(ODEglobal_low, lty = 3)
lines(ODEglobal_high, lty = 3)
```


\newpage

## spatially-explicit models

The models described above were discussed by @noy-meir75 for grazing systems where vegetation is assumed to be of homogeneous distribution, and no spatially-explicit effects are of relevance. 
Refugia or fencing of areas, however, could be considered as spatial effects. 

In arid and semi-arid rangelands, spatial vegetation structure was considered to be of major importance for plant growth and mortality [@rietkerk97; @kefi07]. It generates patterns that act as positive feed-backs on the local scale by providing refugia to grazing and overcome growth limitations at low vegetation cover.

These mechanisms can be implemented in the model by using a pair-approximation approach and numerical simulations, where $G$ and $C$ can be implemented as the transition rates in a two-state spatial model depending on global and local vegetation cover. 

### spatially-explicit growth
  
We implement accelerating and decelerating features on growth and mortality on the local level.

#### accelerating growth

This is assuming that the local environmental suitability is enhanced by a local facilitation term similar to the implementation in Kéfi et al 2007. Thus, the reduction in growth rate, $r$, by aridity, i.e. the inverse of environmental quality $b$, is compensated by a function of $q_{0|1}$, the local density of cells in state 1 (i.e. vegetation) given that the focal cell is in state 0 (i.e. empty), and maximizes to one if the cell has four neighbors:

$$ b = b^* + (1 - b^*)  f q_{0|1} \,,$$

with the effect of aridity, $a_0$ in absence of local vegetation being increased to the value of $f$ if additive facilitation due to the presence of neighboring plants occurs. This term gradually determines the enhancement of the growth with an increasing local vegetation cover (maximizing at $q_{0|1} = 1$ if the cell has 4 neighbors). 


```{r, echo=FALSE}

G <- function(V, q_01 = "auto", r_0 = 1, b = 0.1, f = 0, alpha = 0,  K = 0.9, c = 0) {
  if(q_01 == "auto") q_01 <- 1
  r_0*(b + (1-b)*f*q_01)*V^(1+alpha)*(1-V/(K * (1-c * q_01) ) )

} 

defplot(rho, G(rho, 1, f = 0.8), ylab = "growth", col = "green3")
lines(rho,G(rho, 0.75, f = 0.8), col = "green3")
lines(rho,G(rho, 0.5, f = 0.8), col = "green3")
lines(rho,G(rho, 0.25, f = 0.8), col = "green3")
lines(rho,G(rho, 0, f = 0.8), col = "green3")

lines(rho, C(rho, L = 10))


```

#### decelerating growth

For instance, if plant cover would have a dominantly negative effect on it's surroundings, by depleting nutrients or light, the local neighborhood of a plant cannot be occupied as easy as more remote places. As cover increases and the interspace areas are closing in, the space available for rejuvenation approaches zero. 
This is assuming that growth is diminished locally by competition, $c$. This affects carrying capacity rather than growth rate itself.

$$ K = K^* (1 - c  q_{0|1})$$

That is, if a cell has a fully vegetated local neighborhood, it's carrying capacity will be reduced by $c$. Thus, $c \geq K$ otherwise carrying capacity will fall below $0$ at high cover.

```{r, echo=FALSE}

defplot(rho, G(rho, 1, c = 0.3, b = 0.9), ylab = "growth", col = "green3")
lines(rho,G(rho, 0.75, c = 0.3, b = 0.9), col = "green3")
lines(rho,G(rho, 0.5, c = 0.3, b = 0.9), col = "green3")
lines(rho,G(rho, 0.25, c = 0.3, b = 0.9), col = "green3")
lines(rho,G(rho, 0, c = 0.3, b = 0.9), col = "green3")

lines(rho, C(rho, L = 10))

```



### spatially-explicit mortality

On the mortality side, we can implement spatially explicit effects on the parameters of the functional response. 

#### accelerating mortality

Mortality becomes enhanced in sparse environments by patches that are attracting grazers. We assume this attractivity enhances search efficiency, $a$, locally by the value $v$

$$ a = a^*  + v q_{1|1} $$

Thus, at low local cover feeding will be high on plants with neighbors, whereas at high cover the term has no effect since handling time is limiting consumption. An enhanced search efficiency will raise the critical thresholds for a collapse. 

```{r, echo=FALSE}

C <- function(V, q_01 = 1, m_0 = 0.05, L = 5, a = 0.1, h = 100, q = 0, p = 0, v = 0) (m_0 * V) +( (a+v*q_01  ) *V^(1+q)*L*(1-p*q_01))/(1+(a+v*q_01)*h*(V^(1+q)) ) 


defplot(rho, C(rho, 1, v = 0.5), ylab = "mortality")
lines(rho,C(rho, 0.75, v = 0.5))
lines(rho,C(rho, 0.5, v = 0.5))
lines(rho,C(rho, 0.25, v = 0.5))
lines(rho,C(rho, 0, v = 0.5))

lines(rho, G(rho, b = 0.6), col = "green3")

```


#### decelerating mortality

Plants in grazed habitats develop protective traits, such as thorns or cushion growth. They thereby provide protected habitat to their direct neighborhood, or share the investments in those traits with their neighbors. Overall grazing mortality thus is reduced through an increase in handling time by associational resistance, $p$,

$$ h = h^*  / (1 - p  q_{1|1}) $$

An alternative formulation should be found. The term is highly non-linear and provokes relevant changes only at values above 0.9. It is defined within $(0,1($ 
Instead, we could define associational protection as a reduced impact due to a reduced local density of grazers. 

$$ L = L^* (1 - p  q_{1|1}) $$


```{r, echo=FALSE}

defplot(rho, C(rho, 1, p = 0.8, L = 10), ylab = "mortality")
lines(rho,C(rho, 0.75, p = 0.8, L = 10))
lines(rho,C(rho, 0.5, p = 0.8, L = 10))
lines(rho,C(rho, 0.25, p = 0.8, L = 10))
lines(rho,C(rho, 0, p = 0.8, L = 10))

lines(rho, G(rho, b = 0.6), col = "green3")

```

#### multiple effects 

If those effects coincide, potentially even with the global feedbacks, the intersections are difficult to estimate. 

```{r, echo=FALSE}

defplot(rho, C(rho, 1, p = 0.8, v = 0.6, L = 10, q = .5), ylab = "mortality")
lines(rho,C(rho, 0.75, p = 0.8, v = 0.6, L = 10, q = .5))
lines(rho,C(rho, 0.5, p = 0.8,v = 0.6,  L = 10, q = .5))
lines(rho,C(rho, 0.25, p = 0.8,v = 0.6,  L = 10, q = .5))
lines(rho,C(rho, 0, p = 0.8,v = 0.6,  L = 10, q = .5))

lines(rho, G(rho, 1, c = 0.3, f = 0.9, b = 0.3, alpha = 0.5), col = "green3")
lines(rho,G(rho, 0.75, c = 0.3,f = 0.9,  b = 0.3, alpha = 0.5), col = "green3")
lines(rho,G(rho, 0.5, c = 0.3,f = 0.9,  b = 0.3, alpha = 0.5), col = "green3")
lines(rho,G(rho, 0.25, c = 0.3, f = 0.9, b = 0.3, alpha = 0.5), col = "green3")
lines(rho,G(rho, 0, c = 0.3,f = 0.9,  b = 0.3, alpha = 0.5), col = "green3")


```

### implementation in CA

It is quite straightforward to implement the mechanisms described above in the syntax of a cellular automata model, where the probabilities of transition can not only depend on the global cover $\rho_1$ but also on the local cover in the direct neighborhood of the cell $\nu_1$ (closest 4 cells, von-Neumann-neighborhood). 

the transition probabilities therefore become 

$$ w_{1,0} = m + ( a^* + v q_{1|1})L^* (1 - p  q_{1|1})\rho_1^{q}{1+( a^*  + v q_{1|1})h\rho_1^{1+q}} $$

$$ w_{0,1} = \frac{r \rho_1^{1+\alpha} (b^* + (1 - b^*) f q_{0|1}) (1-\frac{\rho_1}{K^* (1 - c q_{0|1})})}{1-\rho_1} $$


see implementation in NetLogo: `documentation/livestockmodel.nlogo` 


Thus, we can run the CA for a given set of parameters

```{r}

parms <- list(
    m = 0.05,  # intrinsic mortality of plants 
    r = 1,   # growth rate
    f = 0.8, #  local facilitation
    b = 0.4,  # environmental quality inverse of aridity
    K = 0.9,  # carrying capacity
    alpha = 0.1, # water runoff
    c = 0.2, # local competition
    a = 0.6, # search efficiency
    v = 0.1, # attraction effect
    h = 50, # handling time (one individual on landscape unit)
    p = 0.8, # protection effect
    L = 6, # livestock units per landscape unit 
    q = 1 # search ineffiency at low cover
  )

```

```{r, echo = FALSE, warning = FALSE}

set.seed(565432) # setting seed for random number generation

spexmodel <- runCA(0.9, parms, delta = 0.2, t_max = 150, t_min = 100, t_eval = 50, isstable = 0.0001, saveeach = 1)

plot(spexmodel$rho_one ~ spexmodel$time, 
     ylim = c(0,1), ylab = expression( rho["+"]), 
     xlab = "time [yr]", type = "l")
     

```

And the animated lattice would look like this:
```{r, eval = FALSE, echo = FALSE, warning = FALSE}
animateCA(nullmodel, "ca_nullmodel.gif")

![](ca_nullmodel.gif)

```



### implementation in a pair-approximation model

The pair-approximation framework [@matsuda92] is defined as a system of ordinary differential equations, describing the populations of *pairs* of cells. In a two state system, three pairs can be defined with population densities $\rho_{1,1}$ , $\rho_{0,0}$, and $\rho_{0,1}$. Besides, there are the population densities of singletons, $\rho_0$ and $\rho_1$. 

There are conservation equations which allow to calculate population densities of one pair out of the other pairs and singletons.

$$ \rho_1 + \rho_0 = 1$$

$$ \rho_{1,1} + \rho_{0,1} = \rho_1$$

$$ \rho_{0,1} + \rho_{0,0} = \rho_0$$



We can use the transition probabilities of cells  to describe the full system of differential equations.

$$  \frac{\mathrm{d}\rho_{11}}{\mathrm{d}t} = 2 \rho_{10}w_{0,1} - 2 \rho_{11} w_{1,0}  $$

$$  \frac{\mathrm{d}\rho_{1}}{\mathrm{d}t} = \rho_{0}w_{0,1} - \rho_{1}w_{1,0}   $$

$$  \frac{\mathrm{d}\rho_{10}}{\mathrm{d}t} = 2 \rho_{00}w_{0,1} + 2 \rho_{11}w_{1,0} - \rho_{10}w_{0,1}    $$

$$  \frac{\mathrm{d}\rho_{0}}{\mathrm{d}t} = \rho_{1}w_{1,0} - \rho_{0}w_{0,1} $$

$$  \frac{\mathrm{d}\rho_{00}}{\mathrm{d}t} = 2 \rho_{10}w_{1,0} - 2 \rho_{00}w_{0,1}  $$

Due to the conservation equations, two of these are sufficient to fully describe the dynamics of the system. 

We chose to go with the first two and substitute

$$  \frac{\mathrm{d}\rho_{11}}{\mathrm{d}t} = 2 \rho_{10} \frac{r \rho_1^{1+\alpha} (b^* + (1 - b) f q_{0|1})) (1-\frac{\rho_1}{K^* (1 - c q_{0|1})})}{1-\rho_1} - 2 \rho_{11} m -  2 \rho_{11} \frac{(a^*  + v q_{1|1})L^* (1 - p  q_{1|1})\rho_1^{q}}{1+(a^*  + v q_{1|1})h\rho_1^{1+q}}  $$

$$  \frac{\mathrm{d}\rho_{1}}{\mathrm{d}t} = \rho_{0}\frac{r \rho_1^{1+\alpha} (b^* + (1 - b)  f q_{0|1})) (1-\frac{\rho_1}{K^* (1 - c q_{0|1})})}{1-\rho_1} - \rho_{1}m - \frac{(a^*  + v q_{1|1})L^* (1 - p  q_{1|1})\rho_1^{1+q}}{1+(a^*  + v q_{1|1})h\rho_1^{1+q}}   $$

they can be simplified to 


$$  \frac{\mathrm{d}\rho_{11}}{\mathrm{d}t} = 2 \rho_{10} \frac{r \rho_1^{1+\alpha} (b^* + (1 - b)  f q_{0|1})) (1-\frac{\rho_1}{K^* (1 - c q_{0|1})})}{1-\rho_1} - 2 \rho_{11} m -  2 \rho_{11} \frac{(a^*  + v q_{1|1})L^* (1 - p  q_{1|1}) \rho_1^{q}}{1+(a^*  + v q_{1|1})h)\rho_1^{1+q}}  $$

$$  \frac{\mathrm{d}\rho_{1}}{\mathrm{d}t} = r \rho_1^{1+\alpha} (b^* + (1 - b)  f q_{0|1})) (1-\frac{\rho_1}{K^* (1 - c q_{0|1})}) - \rho_{1}m - \frac{(a^*  + v q_{1|1})L^* (1 - p  q_{1|1})\rho_1^{1+q}}{1+(a^*  + v q_{1|1})h\rho_1^{1+q}}   $$


as a matter of fact the equation for $\frac{\mathrm{d}\rho_{1}}{\mathrm{d}t}$ will re-convert into the regular population equation. 

Since formally $q_{i|j}$ is a conditional probability (given that one neighbor is in state $i$, what is the probability to find the other in state $j$) we can express it in terms of densities of pairs and ‘singletons,’ as  

$$ q_{i|j} = \frac{\rho_{ij}}{\rho_i} $$

thus,

$$ q_{0|1} = \frac{\rho_{10}}{\rho_0} =  \frac{\rho_{1} - \rho_{11}}{1 - \rho_1} $$

$$ q_{1|1} = \frac{\rho_{11}}{\rho_1} $$

and substituting yields


$$  \frac{\mathrm{d}\rho_{11} }{\mathrm{d}t} = 2 (\rho_1 - \rho_{11}) \frac{r \rho_1^{1+\alpha} (b^* + (1 - b)  f \frac{\rho_{1} - \rho_{11}}{1 - \rho_1} )) (1-\frac{\rho_1}{K^* (1 - c \frac{\rho_{1} - \rho_{11}}{1 - \rho_1})})}{1-\rho_1} - 2 \rho_{11} m -  2 \rho_{11} \frac{(a^*  + v \frac{\rho_{11}}{\rho_1})L^* (1 - p \frac{\rho_{11}}{\rho_1})\rho_1^{q}}{1+(a^*  + v \frac{\rho_{11}}{\rho_1})h\rho_1^{1+q}}  $$

$$  \frac{\mathrm{d}\rho_{1}}{\mathrm{d}t} = r \rho_1^{1+\alpha} (b^* + (1 - b) f  \frac{\rho_{1} - \rho_{11}}{1 - \rho_1}) (1-\frac{\rho_1}{K^* (1 - c \frac{\rho_{1} - \rho_{11}}{1 - \rho_1})}) - \rho_{1}m -  \frac{(a^*  + v \frac{\rho_{11}}{\rho_1})L^* (1 - p \frac{\rho_{11}}{\rho_1})\rho_1^{1+q}}{1+(a^*  + v \frac{\rho_{11}}{\rho_1})h\rho_1^{1+q}}   $$

for the set of parameters given above, we get the following dynamics

```{r, echo=FALSE}

rho <- c(rho_1 = 0.9, rho_11 = 0.8, rho_10 = 0.1, rho_00 = 0, rho_0 = 0.1)

d_rho_1 <- function(rho, parms) { 
  with(parms,
       r * (b + (1 - b) * f * (rho[1] - rho[2])/(1- rho[1]) ) * rho[1]^( 1 + alpha) * (1 - rho[1]/(K * (1-c*(rho[1] - rho[2])/(1- rho[1])) ) ) - m * rho[1] - ( (a + v*rho[2]/rho[1]) * rho[1]^( 1 + q) * L * (1 - p * rho[2]/rho[1]))/(1 +(a + v*rho[2]/rho[1]) * h  * rho[1]^( 1 + q)) 
       )  
  }
  

d_rho_11 <- function(rho,  parms) { 
  with(parms,
       2* (rho[1] - rho[2]) * r * ( b + (1 - b) * f * (rho[1] - rho[2])/(1- rho[1]) ) * rho[1]^( 1 + alpha) * (1 - rho[1]/(K * (1-c*(rho[1] - rho[2])/(1- rho[1])) ) ) / (1-rho[1]) - 2 * rho[2] * m  - 2 * rho[2] * ( (a + v*rho[2]/rho[1]) * rho[1]^( 1 + q) * L * (1 - p * rho[2]/rho[1]))/(1 +(a + v*rho[2]/rho[1]) * h  * rho[1]^( 1 + q)) 
       )  
  }
  

odesys_spex <- function(t, rho, parms = model_parms) {
  rho_1 <- d_rho_1(rho, parms)
  rho_11 <- d_rho_11(rho, parms)
  list(c(rho_1, rho_11, rho_1-rho_11, 1-rho_1-(rho_1-rho_11),1-rho_1  
               ) )
}


# running the ode-solver
ODE_spex <- ode(y = rho, func = odesys_spex, times = 1.1^(1:50), parms = parms)


# transfer into ouput and calculate missing rho values
ODE_spex <- as.data.frame(ODE_spex )

plot(rho_1 ~ time , data = ODE_spex , type = "l", ylim = c(0,1))
axis(4, at = round(tail(ODE_spex,1)$rho_1,2),cex.axis = 0.7, las = 1 )

lines(spexmodel$rho_one ~ spexmodel$time, col = "grey50")
     

```

Now, we can also plot the clustering coefficient of this landscape, being 

$$ c_11 = q_{1|1}/\rho_1 = \frac{\rho_11}{\rho_1^2}$$

```{r, echo=FALSE}
plot(I(rho_11/rho_1^2) ~ time , data = ODE_spex , type = "l", ylim = c(0,2))

```

### Bifurcation diagrams


```{r, echo=FALSE}

parms$b <- seq(0,1,.005) #seq(0,1,.002)+0.001
parms$rho_ini <- c(0.9, 0.01)

iterations <- expand.grid(parms)
iterations <- cbind(ID = 1:dim(iterations)[1],iterations)

iterations$f[iterations$f < iterations$b] <- iterations$b[iterations$f < iterations$b]


# provides parallel backend
library(foreach)
library(doSNOW)

workstation <-  list(host = "162.38.184.118", user = "schneider",
                     rscript = "/usr/lib/R/bin/Rscript",
                     snowlib = "/usr/lib/R/library")

workerlist <- c(rep("localhost", times = 10)) 

cl <- makeSOCKcluster(workerlist, master="162.38.184.88", outfile='out_messages.txt')

registerDoSNOW(cl)


foreach(iteration = iterations$ID, .combine = rbind, .packages = c("deSolve")) %dopar% { 
  source("C:/Users/SCHNEIDER/Documents/projects/CAS02_livestock/code/simfunctions.r")
  
  model_parms <- as.list(iterations[iteration,])
  
  # running the ode-solver
  runmodel <- ode(y = ini_rho(model_parms$rho_ini), func = odesys_spex, times = c(1,1000), parms = model_parms)
 
  # transfer into ouput and calculate missing rho values
  return(as.data.frame(runmodel)[dim(runmodel)[1],])
  } -> output

output <- cbind(output, iterations)

plot(rho_1 ~ b, data = cbind(output, iterations), type = "p", pch  = 20, ylim = c(0,1))


```





```{r, echo=FALSE}


parms$L <- seq(0,20,0.2) #seq(0,1,.002)+0.001
parms$b <- 0.4
parms$rho_ini <- c(0.9, 0.01)

iterations <- expand.grid(parms)
iterations <- cbind(ID = 1:dim(iterations)[1],iterations)

iterations$f[iterations$f < iterations$b] <- iterations$b[iterations$f < iterations$b]


foreach(iteration = iterations$ID, .combine = rbind, .packages = c("deSolve")) %dopar% { 
  source("C:/Users/SCHNEIDER/Documents/projects/CAS02_livestock/code/simfunctions.r")
  
  model_parms <- as.list(iterations[iteration,])
  
  # running the ode-solver
  runmodel <- ode(y = ini_rho(model_parms$rho_ini), func = odesys_spex, times = c(1,1000), parms = model_parms)
 
  # transfer into ouput and calculate missing rho values
  return(as.data.frame(runmodel)[dim(runmodel)[1],])
  } -> output

output <- cbind(output, iterations)

plot(rho_1 ~ L, data = cbind(output, iterations), type = "p", pch  = 20, ylim = c(0,1))




stopCluster(cl)


```



## analytical solutions




# References